#summary Overview of the internals of signFinder.
#labels Featured,Phase-Implementation
In Progress

= System Overview =
The following image describes the different modules in signFinder, and the data-flow between them.

[http://mirror.openstreetmap.nl/openstreetphoto/tijs/results/data/signFinder%20System%20Overview.png]
[http://mirror.openstreetmap.nl/openstreetphoto/tijs/results/data/ originals]

On this wiki-page, each of the modules, their internal working, and their location in the code-base will be described.

== Color-histogram matching ==
The first stage when receiving an image, is to perform color-histogram matching on it. The color-histogram matcher reads positive and negative color histogram samples from the postHist.hist and negHist.hist files as generated by the [trainer] executable (See also [TrainingOtherCountries]). These binned histograms basically contain color-counts: How often has a specific color occurred in a street-sign (positive sample), and how often has a specific color occurred outside a street-sign (negative sample). Each colored pixel is compared against the color histogram. It's marked positive if it's color contains at least THRESHOLD times more often in the positive sample than in the negative sample.
Current threshold (as of 17/08) is 0.19. This is on the low side, but can be explained by the fact that area's outside the streetsigns in the training image are often much larger than area's inside the image. Moreover, the histogram matching is intentionally positively-biased. The Blob classification step deals with an excess of positively marked pixels. This results in an binary image with the same size as the original image, marking the positively-marked (white) and negatively-marked(black) pixels.

The histogram-matcher is accessed in the {{{SignFinder::histMatch()}}} function in the signFinder class (signFinder.cpp). The histograms are loaded in the {{{_posHist}}} and {{{_negHist}}} variables on object creation. This function uses the histogram-matcher in ./lib/histogramtool

== Blob Detection ==
The binary image from the color-histogram matching stage contains a number of connected area's (area's where you could get from every place inside the area to another, by only crossing white pixels), which could potentially contain street-signs. It's non-trivial (and computationally expensive) to detect these different area's or 'blobs'.

These blobs are detected with 'bloblib' residing in ./lib/bloblib . The blob-detector is accessed in the {{{SignFinder::readSigns()}}} main entry function by calling the {{{CBlobResult()}}} constructor.

== Blob Classification ==
The Blob-detector offers a list of connected area's or blobs, each of which could potentially be a street-sign. However many blobs are just misdetected patches of sky, misdetected other objects, or just blobs consisting of a few pixels marking an artifact that just happened to have the right color. From all these blobs, we have to select the blobs that are likely to contain a street-sign. We classify the blobs based on the following characteristics:
  * size: Blobs with a total area covering less than 1/600th of the area of the total image, are rejected. Smaller blobs might still contain a street-sign, but it's unlikely that it'll have sufficient resolution to be read by OCR anyway.
  * connecting to sides of image: Blobs contacting one of the sides of the image, are rejected as well. Signs that have contact with the side of the image are likely to contain only a part of the image, and this approach has the additional advantage that it filters out much of the sky.
  * squareness: Squareness is the ratio between the area and the width times the height of the blob. Note that width and height are not the length along the x and y axis in the image, but are a measure of the actual size of the blob which doesn't change if the blob rotates. Weak blobs tend to have relative big areas that aren't detected positively or 'holes' in them, which causes the squareness-ratio to drop. Blobs with a squareness below 0.7 are rejected.
  * X/Y ratio: Street signs are always wider than that they're high. Assuming that the picture was taken with a approximately straight horizon, we expect blobs containing street-signs to cover more pixels along the width of the image (the x axis) than the height of the image (the y axis). If a blob covers significantly more space over the y axis than the x axis, and the X/Y ratio drops below 0.45, it is rejected.
  * W/H ratio: Given the previous assumption that street-signs are always wider than that they're high, we can also formulate a minimum for the actual ratio between width and height. If a blob is less than 2.5 times as wide as it's high, the W/H ratio drops below 2.5, and it's rejected.
A list of blobs with their respective characteristics and whether they're accepted or not can be displayed by starting [signFinder] with the -v option. Blobs rejected based on the first two charecteristics aren't displayed, as this would cause the list too large to interpret comfortably.

The code to generate characteristics over blobs, display these, and filter them can be found in the {SignFinder::classifyBlobs()} function in signFinder.cpp . This function also compares detected blobs with known-correct labels in order to measure performance of sign-detecting portion of the system. More about that in the last chapter of this document.

== Convex Hull ==

== Cut & Perspective Correction ==

== Tesseract OCR ==

== street-name heutistics ==


= Performance Measurement =
If labels are present, signFinder automatically measures and reports its performance.

== Street-sign detection ==

== Street-sign reading ==